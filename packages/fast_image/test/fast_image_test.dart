import 'dart:typed_data';
import 'package:fast_image/fast_image.dart';
import 'package:test/test.dart';

void main() {
  group('FastImage', () {
    test('loads image from file', () {
      // This test would require an actual image file
      // For now, we just check that the exception is thrown for missing files
      expect(
        () => FastImage.fromFile('nonexistent.jpg'),
        throwsA(isA<LoadException>()),
      );
    });

    test('loads image from memory', () {
      // Create a minimal valid PNG (1x1 transparent pixel)
      final pngData = Uint8List.fromList([
        0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, // PNG signature
        0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52, // IHDR chunk
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, // 1x1 dimensions
        0x08, 0x06, 0x00, 0x00, 0x00, 0x1F, 0x15, 0xC4,
        0x89, 0x00, 0x00, 0x00, 0x0A, 0x49, 0x44, 0x41, // IDAT chunk
        0x54, 0x78, 0x9C, 0x63, 0x00, 0x01, 0x00, 0x00,
        0x05, 0x00, 0x01, 0x0D, 0x0A, 0x2D, 0xB4, 0x00,
        0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, // IEND chunk
        0x42, 0x60, 0x82,
      ]);

      final image = FastImage.fromMemory(pngData);
      expect(image.width, equals(1));
      expect(image.height, equals(1));
      image.dispose();
    });

    test('gets metadata correctly', () {
      final pngData = Uint8List.fromList([
        0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A,
        0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x08, 0x06, 0x00, 0x00, 0x00, 0x1F, 0x15, 0xC4,
        0x89, 0x00, 0x00, 0x00, 0x0A, 0x49, 0x44, 0x41,
        0x54, 0x78, 0x9C, 0x63, 0x00, 0x01, 0x00, 0x00,
        0x05, 0x00, 0x01, 0x0D, 0x0A, 0x2D, 0xB4, 0x00,
        0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE,
        0x42, 0x60, 0x82,
      ]);

      final image = FastImage.fromMemory(pngData);
      final metadata = image.getMetadata();
      
      expect(metadata.width, equals(1));
      expect(metadata.height, equals(1));
      expect(metadata.colorType, isA<ColorType>());
      
      image.dispose();
    });

    test('encodes image to buffer', () {
      final pngData = Uint8List.fromList([
        0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A,
        0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x08, 0x06, 0x00, 0x00, 0x00, 0x1F, 0x15, 0xC4,
        0x89, 0x00, 0x00, 0x00, 0x0A, 0x49, 0x44, 0x41,
        0x54, 0x78, 0x9C, 0x63, 0x00, 0x01, 0x00, 0x00,
        0x05, 0x00, 0x01, 0x0D, 0x0A, 0x2D, 0xB4, 0x00,
        0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE,
        0x42, 0x60, 0x82,
      ]);

      final image = FastImage.fromMemory(pngData);
      final encoded = image.encode(ImageFormatEnum.Png);
      
      expect(encoded, isA<Uint8List>());
      expect(encoded.isNotEmpty, isTrue);
      
      image.dispose();
    });

    test('throws when using disposed image', () {
      final pngData = Uint8List.fromList([
        0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A,
        0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
        0x08, 0x06, 0x00, 0x00, 0x00, 0x1F, 0x15, 0xC4,
        0x89, 0x00, 0x00, 0x00, 0x0A, 0x49, 0x44, 0x41,
        0x54, 0x78, 0x9C, 0x63, 0x00, 0x01, 0x00, 0x00,
        0x05, 0x00, 0x01, 0x0D, 0x0A, 0x2D, 0xB4, 0x00,
        0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE,
        0x42, 0x60, 0x82,
      ]);

      final image = FastImage.fromMemory(pngData);
      image.dispose();
      
      expect(
        () => image.getMetadata(),
        throwsStateError,
      );
    });

    test('filter type enum has all values', () {
      expect(FilterTypeEnum.Nearest.value, equals(0));
      expect(FilterTypeEnum.Triangle.value, equals(1));
      expect(FilterTypeEnum.CatmullRom.value, equals(2));
      expect(FilterTypeEnum.Gaussian.value, equals(3));
      expect(FilterTypeEnum.Lanczos3.value, equals(4));
    });

    test('image format enum has all values', () {
      expect(ImageFormatEnum.Png.value, equals(0));
      expect(ImageFormatEnum.Jpeg.value, equals(1));
      expect(ImageFormatEnum.Gif.value, equals(2));
      expect(ImageFormatEnum.WebP.value, equals(3));
      expect(ImageFormatEnum.Bmp.value, equals(4));
      expect(ImageFormatEnum.Ico.value, equals(5));
      expect(ImageFormatEnum.Tiff.value, equals(6));
    });

    test('color type enum has all values', () {
      expect(ColorType.l.value, equals(0));
      expect(ColorType.la.value, equals(1));
      expect(ColorType.rgb.value, equals(2));
      expect(ColorType.rgba.value, equals(3));
    });
  });
}

